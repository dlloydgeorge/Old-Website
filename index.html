<!DOCTYPE html>
<html lang="eng">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuDecoDev</title>
    <link rel="stylesheet" href="css/styles.css">

</head>
<body>

    <!-- Add the Menu Bar-->
    <div class="navbar">
        <div class="title">
            <span>QuDeco</span>
        </div>
        <a href="index.html" class="active">Game</a>
        <a href="explanation.html">Background</a>
    </div>

    
    <div id="container">
        <div id="threeCanvas"></div>
    </div>
    
    
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> -->

    <!-- Main Game Script-->
    <script type="module">
        // import stuff
        import {
            BlochSphere
        } from "/src/quantum/bloch_sphere.js";

        import * as THREE from '/src/libs/three/three.module.js';

        import {
            CSS2DRenderer
        } from "/src/libs/three/jsm/renderers/CSS2DRenderer.js";

        import {
            OrbitControls
        } from "/src/libs/three/jsm/controls/OrbitControls.js";

        const STEPS_PER_FRAME = 5;


        /**
        This is the main object for the qubit system
        the initial state is defined using the bloch vector definition 
        T1: the amplitude dampening time (in seconds)
        T2: Phase dampening time (in seconds)
        */
        const qubitSystemInfo = {InitialState: new THREE.Vector3(1,0,0), Hamiltonian: "filler", T1: 2.0, T2: 4.0}
        // Set up scene
        let canvas = document.getElementById("threeCanvas");
        let canvasWidth = canvas.offsetWidth;
        let canvasHeight = canvas.offsetHeight;

        // set diameter to 80% of canvas size
        let diameter = (Math.min(canvasWidth, canvasHeight) / 100) * 80;

        let scene = new THREE.Scene();
        const FOV = 45;
        const Aspect = canvasWidth / canvasHeight;
        const Near = 0.1;
        const Far = diameter * 2;
        let camera = new THREE.PerspectiveCamera(FOV, Aspect, Near, Far);
        camera.position.set(diameter, diameter, diameter);
        camera.lookAt(new THREE.Vector3(0,0,0));
        scene.add(camera);

        let light = new THREE.DirectionalLight(0xFFFFFF);
        scene.add(light)

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        var labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = 0;

        canvas.appendChild(renderer.domElement);
        canvas.appendChild(labelRenderer.domElement);

        var controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.minDistance = diameter / 4;
        controls.maxDistance = diameter * 2;

        // Create Bloch Sphere with less dense wireframe
        /**
        const bloch_sphere_radius = 2;
        const sphereGeometry = new THREE.SphereGeometry(bloch_sphere_radius, 16, 16); // Adjust the number of segments here
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        */ 
       var blochSphereStateProperties =  {
            theta: "90.0000",
            phi: "90.0000"
        };

        var blochSphere = new BlochSphere(diameter / 2, {
            theta: blochSphereStateProperties.theta,
            phi: blochSphereStateProperties.phi,
            color: new THREE.Color(0xFFFFFF),
            axesLength: (diameter / 2) + ((diameter / 2) * 0.2),
            axesWidth: 2
        });

        scene.add(blochSphere);
        // Create Arrow
        /*
        const arrowGeometry = new THREE.CylinderGeometry(0, 0.05, 0.3, 20, 1);
        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
        arrow.position.set(2, 0, 0); // Initial position of the arrow
        scene.add(arrow);
        */

        
        const dir = new THREE.Vector3( 1, 2, 0 );
        dir.normalize();
        const origin = new THREE.Vector3( 0, 0, 0 );
        const length = diameter / 2;
        const hex = 0xffff00;
        const arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex );
        scene.add( arrowHelper );
        

        // Add axes
        /**
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        */ 

        
        const keyStates = {};
        // key press stuff
        document.addEventListener( 'keydown', ( event ) => {

            keyStates[ event.code ] = true;

        } );

        document.addEventListener( 'keyup', ( event ) => {

            keyStates[ event.code ] = false;

        } );

        // For Keyboard presses
        function keyControls() {
            if (keyStates['KeyX']) {
                //arrowHelper.rotation.x = Math.PI;
                blochSphere.updateBlochSphereState(new THREE.Vector3(1,0,0), Math.PI);
            }

            if (keyStates['KeyY']) {
                //arrowHelper.rotation.y = Math.PI;
                blochSphere.updateBlochSphereState(new THREE.Vector3(0,1,0), Math.PI);
            }

            if (keyStates['KeyZ']) {
                //arrowHelper.rotation.z = Math.PI;
                blochSphere.updateBlochSphereState(new THREE.Vector3(0,0,1), Math.PI);
            }

        }
        
        // all mathematical operations for computing the bloch vector should go in here
        function computeNewBlochVector(time){
            
        }

        // Function to animate the Bloch Sphere and Arrow
        function animate() {
            
            // Rotate the arrow around the Bloch sphere
            const angle2 = Date.now() * 0.005; // Adjust speed of rotation
            const angle = 0.0001;
            //arrowHelper.position.x = (diameter / 2) * Math.cos(angle2) * Math.exp(-angle2);
            //arrowHelper.position.z = (diameter / 2) * Math.sin(angle2);
            arrowHelper.rotation.y = -angle2;
            let arrowLength = (diameter / 2) * Math.exp(-angle2);
            arrowHelper.setLength(arrowLength, arrowLength / 10, arrowLength / 30)
            for ( let i = 0; i < STEPS_PER_FRAME; i ++ ) {
                blochSphere.updateBlochSphereState(new THREE.Vector3(0,0,1), angle);
                keyControls();
            }
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        animate();
        // Adjust rendering when window is resized
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
