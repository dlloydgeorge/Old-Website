<!DOCTYPE html>
<html>
<body>
<h1> DLG Website</h1>
<p>This is DLG's personal website. It is still a work in progress so give it some time. I may add some experimental features in HTML and Javascript.</p>

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>   

<h1> QuDeco Game Dev </h1>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuDecoDev</title>
    <link rel="stylesheet" href="css/styles.css">

</head>
<body>
    <div id="container">
        <div id="threeCanvas"></div>
        <div id="buttonsContainer">
            <button onclick="toggleAnimation()">Toggle Animation</button>
            <button onclick="changeColor()">Change Color</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        let camera, scene, renderer;
        let bloch_sphere_radius = .8 * Math.min(window.innerHeight, window.innerHeight)

        // Initialize Three js stuff
        function init() {

            // Set up the scene, camera, and renderer
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer( {antialias: true});
            renderer.setSize(window.innerWidth * 0.7, window.innerHeight);
            document.getElementById('threeCanvas').appendChild(renderer.domElement);

            // Create arrow geometry
            const arrowGeometry = new THREE.ConeGeometry(0.1, 0.5, 32);
            let arrowMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            scene.add(arrow);
            arrow.position.z = -5;

            const sphereGeometry = new THREE.SphereGeometry(bloch_sphere_radius, 32, 32 );
			const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.3 } );
			const sphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
			scene.add(sphere);

        }
        
        

        // Animate the arrow
        let isAnimating = true;
        function animate() {
            if (isAnimating) {
                requestAnimationFrame(animate);

                // Rotate the arrow
                arrow.rotation.y += 0.01;

                renderer.render(scene, camera);
            }
        }

        // Toggle animation
        function toggleAnimation() {
            isAnimating = !isAnimating;
        }

        // Change arrow color
        function changeColor() {
            const color = new THREE.Color(Math.random(), Math.random(), Math.random());
            arrowMaterial = new THREE.MeshBasicMaterial({ color: color });
            arrow.material = arrowMaterial;
        }

        // Start the animation
        init();
        animate();
    </script>
</body>
  <p>
    This is a game designed to illustrate how dynamical decoupling (sequences of pulses) can reduce decoherence in a qubit and extend its lifetime.
    A qubit is the fundamental unit of quantum computation, analagous to a bit in classical computation. It is represented by a two state quantum system. 
    An arbitary state of a qubit can be represented by a statevector of the following form: 
    $$ \ket{\psi} = \alpha \ket{0} + \beta \ket{1} $$
This state can be generalized to a density matrix that allows for the consideration of mixed states. The state $\ket{\psi}$ can be written out as the following density matrix: 
	$$ \rho = \ket{\psi} \bra{\psi} $$
We can solve for the general evolution of the density matrix using the master equation/ GKSL equation ($\hbar = 1$):
$$ \dot{\rho} = - i [H, \rho]  + \sum_i \gamma_i \left( L_i \rho L^{\dagger}_i + \frac{1}{2} \left \{  L_i^{\dagger } L_i, \rho \right\}\right)$$
where $L_i $ are the lindbladian/jump operators that represent the dissipative dynamics associated with the interaction of a qubit with its environment. We would like to solve this equation to find the dynamics of the qubit however we first need a way to visualize the qubit. For single qubit quantum state, we can represent an arbitrary density matrix with the following form: 
$$ \rho = \frac{1}{2} (I + \vec{r}\cdot \vec{\sigma})$$
Where $\vec{r}$ represents the amplitude associated with each pauli matrix. We can plot $\vec{r}$ as a 3d vector on the bloch sphere, visualizing it in the process. We would ideally like to reexpress the GKSL equation in terms of $\vec{r}$ as that is ultimately what is used for plotting. We can start by solving for this with the GKSL with no dissipative dynamics and representing the qubit hamiltonian as a linear combination of pauli matrices: 
$$\hat{H} = h_0 I + \vec{h}\cdot \vec{\sigma} \qquad 
	\dot{\rho} = - i [\hat{H}, \rho] 
$$
</html>
